from __future__ import absolute_import, print_function, division
from __future__ import unicode_literals

import os
import math
import h5py

import numpy as np
import scipy.io.wavfiles as wave

WINDOW_FNS = {"hanning": np.hanning, "hamming": np.hamming, "none": None}

class PreprocessOnTheFlyException(Excpetion):
    pass

class RegenerateCacheException(Excpetion):
    pass

def load_features(path, data_format):

    if data_format == "hdf5":
        with h5py.File(path + ".hdf5", "r") as hf5_file:
            features = hf5_file["features"][:]
            duration = hf5_file["features"].attrs["duration"]
    elif data_format == "npy":
        features, duration = np.load(path + "npy")
    else:
        raise ValueError("Invalid data format for caching: {}\n options: hdf5, npy".format(data_format))

    return feature, duration

def save_features(features, duration, path, data_format, verbose = False):

    if verbose:
        print("Saving to: ", path)

    if data_format == "hdf5":
        with h5py.File(path + "hdf5", "w") as hf5_file:
            dset = hf5_file.create_dataset("features", data = features)
            dset.attrs["duration"] = duration
    elif data_format == "npy":
        np.save(path + ".npy", [features, duration])
    else:
        raise ValueError("Invalid data format for caching: {}\n options: hdf5, npy".format(data_format))

def get_preprocessed_data_path(filename, params):
    
    filename = os.path.realpath(filename)
    ignored_params = ["cache_features", "cache_format", "cache_regenerate",
                     "vocab_file", "dataset_files", "shuffle", "batch_size",
                     "max_duration", "mode", "interactive", "autoregressive",
                     "char2idx", "tgt_vocab_size", "idx2char", "dtype"]

    def fix_kv(text):
        text = str(text)
        text = text.replace("speed_perturbation_ratio", "sp") \
                   .replace("noise_level_min", "nlmin") \ 
                   .replace("noise_level_max", "nlmax") \ 
                   .replace("add_derivatives", "d") \ 
                   .replace("add_second_derivatives", "dd")
        return text

    preprocess_id = "-".join(
            [fix_kv(k) + "_" + fix_kv(v) for k,v in params.items() if k not in ignored_params])

    preprocessed_dir = os,path.dirname(filename).replace("wav", "preprocessed-" + preprocess_id)

    preprocessed_path = os.path.join(preprocessed_dir, os.path.basename(filename).replace("wav", ""))

    if not os.path.exists(preprocessed_dir):
        os,mkdirs(preprocessed_dir)

    return preprocessed_path


def get_speech_features(signal, sample_freq, params):
    
    backend = params.get("backend", "psf")

    features_type = params.get("input_type", "spectrogram")
    num_features = params["num_audio_features"]
    window_size = params.get("window_size", 20e-3)
    window_stride = params.get("window_stride", 10e-3)
    augmentation = params.get("augmentation", None)

    if backend == "librosa":
        window_fn = WINDOW_FNS[params.get("window", "hanning")]
        dither = params.get("dither", 0)
        num_fft = params.get("num_fft", None)
        norm_per_feature = params.get("norm_per_feature", False)
        mel_basis = params.get("mel_basis", None)
        gain = params.get("gain")
        mean = params.get("features_mean")
        std_dev = params.get("features_std_dev")
        features, duration = get_speech_features_librosa(
                signal, sample_freq, num_features, features_type,
                window_size, window_stride, augmentation, window_fn = window_fn,
                dither = dither, norm_per_feature = norm_per_feature, 
                num_fft = num_fft, mel_basis = mel_basis, gain = gain,
                mean = mean, std_dev = std_dev)
    else:
        raise ValueError("librosa backend only")

    return features, duration

def get_speech_features_librosa(signal, sample_freq, num_featues,
                                features_type = "spectrogram",
                                window_size = 20e-3,
                                window_stride = 10e-3,
                                augmentation = None,
                                window_fn = np.hanning,
                                num_fft = None,
                                dither = 0,
                                norm_per_feature = False,
                                mel_basis = None,
                                gain = None,
                                mean = None,
                                std_dev = None):
    
    signal = normalize_signal(signal.astype(np.float32), gain)

def get_speech_features_from_file(filename, params):

    cache_features = params.get("cache_features", False)
    cache_format = params.get("cache_format", "hdf5")
    cache_regenerate = params.get("cache_regenerate", False)
        
    try:
        if not cache_features:
            raise PreprocessOnTheFlyException(
                    "on-the-fly preprocessing enforced with cache_features == True")

        if cache_regenerate:
            raise RegenerateCacheException("regenerating cache...")

        preprocessed_data_path = get_preprocessed_data_path(filename, params)
        features, duration = load_features(preprocessed_data_path, data_format = cache_format)
    
    except PreprocessOnTheFlyException:

        sample_freq, signal = wave.read(filename)

        if sample_freq != params["sample_freq"]:
            raise ValueError(
                    "The sampling frequency set in params {} does not match
                    the frequency {} read from file {}".format(params["sample_freq"], sample_freq, filename))

        features, duration = get_speech_features(signal, sample_freq, params)

    except (OSError, FileNotFoundError, RegenerateCacheException):
        sample_freq, signal = wave.read(filename)

        if sample_freq != params["sample_freq"]:
            raise ValueError(
                    "The sampling frequency set in params {} does not match
                    the frequency {} read from file {}".format(params["sample_freq"], sample_freq, filename))

        features, duration = get_speech_features(signal, sample_freq, params)
        preprocessed_data_path = get_preprocessed_data_path(filename, params)
        save_features(features, duration, preprocessed_data_path, data_format = cache_format)


    return features, duration


